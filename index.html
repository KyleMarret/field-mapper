<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>KAS Field Sampler</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
        }
        
        #map {
            height: 100vh;
            width: 100vw;
        }
        
        /* Main Control Panel */
        .control-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            width: 320px;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 12px 12px 0 0;
            font-weight: 600;
            font-size: 18px;
        }
        
        .panel-section {
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .panel-section:last-child {
            border-bottom: none;
        }
        
        .section-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Form Elements */
        .form-group {
            margin-bottom: 12px;
        }
        
        .form-label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }
        
        .form-input, .form-select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }
        
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        
        /* Buttons */
        .btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            margin: 4px 0;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5a67d8;
        }
        
        .btn-success {
            background: #48bb78;
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
        }
        
        .btn-warning {
            background: #ed8936;
            color: white;
        }
        
        .btn-warning:hover {
            background: #dd6b20;
        }
        
        .btn-danger {
            background: #f56565;
            color: white;
        }
        
        .btn-danger:hover {
            background: #e53e3e;
        }
        
        .btn-outline {
            background: white;
            color: #667eea;
            border: 1px solid #667eea;
        }
        
        .btn-outline:hover {
            background: #667eea;
            color: white;
        }
        
        .btn-group {
            display: flex;
            gap: 8px;
        }
        
        .btn-group .btn {
            flex: 1;
        }
        
        /* Lists */
        .field-list, .soil-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
        }
        
        .field-item, .soil-item {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .field-item:hover, .soil-item:hover {
            background: #e9ecef;
        }
        
        .field-item.active {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .soil-item.active {
            border-color: #48bb78;
            background: #f0fff4;
        }
        
        .field-name, .soil-name {
            font-weight: 500;
            color: #333;
        }
        
        .field-details, .soil-details {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        
        .item-actions {
            display: flex;
            gap: 8px;
        }
        
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .icon-btn:hover {
            opacity: 1;
        }
        
        /* Layer Controls */
        .layer-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 200px;
        }
        
        .layer-toggle {
            display: flex;
            align-items: center;
            margin: 8px 0;
            cursor: pointer;
        }
        
        .layer-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            cursor: pointer;
        }
        
        .layer-toggle label {
            cursor: pointer;
            font-size: 14px;
        }
        
        /* Status Bar */
        .status-bar {
            position: fixed;
            bottom: 70px;
            left: 10px;
            background: white;
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 12px;
            max-width: calc(100vw - 20px);
            overflow-x: auto;
        }
        
        .status-item {
            display: inline-block;
            margin-right: 15px;
        }
        
        .status-label {
            color: #666;
            margin-right: 5px;
        }
        
        .status-value {
            font-weight: 600;
            color: #333;
        }
        
        /* Sync Status */
        .sync-status {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 20px;
            padding: 8px 16px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1001;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .sync-status.synced {
            background: #d4edda;
            color: #155724;
        }
        
        .sync-status.syncing {
            background: #fff3cd;
            color: #856404;
        }
        
        .sync-status.offline {
            background: #f8d7da;
            color: #721c24;
        }
        
        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .sync-status.synced .sync-dot {
            background: #28a745;
        }
        
        .sync-status.syncing .sync-dot {
            background: #ffc107;
        }
        
        .sync-status.offline .sync-dot {
            background: #dc3545;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Toolbar */
        .toolbar {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 30px;
            padding: 10px 20px;
            display: flex;
            gap: 15px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .tool-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: none;
            background: white;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        .tool-btn.active {
            background: #667eea;
            color: white;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            top: 70px;
            right: 50%;
            transform: translateX(50%);
            background: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 9999;
            display: none;
            animation: slideDown 0.3s ease;
        }
        
        .toast.show {
            display: block;
        }
        
        @keyframes slideDown {
            from {
                transform: translateX(50%) translateY(-100%);
            }
            to {
                transform: translateX(50%) translateY(0);
            }
        }
        
        /* File Upload */
        .file-upload {
            position: relative;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }
        
        .file-upload input[type="file"] {
            position: absolute;
            left: -9999px;
        }
        
        .file-upload-label {
            display: block;
            padding: 10px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 6px;
            text-align: center;
            font-size: 14px;
            color: #666;
            transition: all 0.2s;
        }
        
        .file-upload-label:hover {
            background: #e9ecef;
            border-color: #667eea;
            color: #667eea;
        }
        
        .no-data {
            padding: 20px;
            text-align: center;
            color: #999;
            font-size: 14px;
        }
        
        /* Mobile Responsive */
        @media screen and (max-width: 768px) {
            .control-panel {
                width: 280px;
                max-width: 85vw;
            }
            
            .layer-controls {
                right: 10px;
                top: 60px;
                min-width: 150px;
            }
            
            .sync-status {
                font-size: 10px;
                padding: 6px 12px;
            }
            
            .status-bar {
                font-size: 10px;
                padding: 8px 10px;
            }
            
            .toolbar {
                bottom: 10px;
                padding: 8px 12px;
                gap: 10px;
            }
            
            .tool-btn {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <!-- Sync Status -->
    <div class="sync-status" id="syncStatus">
        <div class="sync-dot"></div>
        <span id="syncStatusText">Connecting...</span>
    </div>
    
    <!-- Toast -->
    <div class="toast" id="toast"></div>
    
    <!-- Main Control Panel -->
    <div class="control-panel" id="mainPanel">
        <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
            <span>KAS Field Sampler</span>
            <button onclick="toggleMainPanel()" style="background: none; border: none; cursor: pointer; font-size: 20px; color: white; padding: 0; width: 24px; height: 24px;" id="mainPanelToggleBtn">−</button>
        </div>
        <div id="mainPanelContent">
            <!-- Grower Section -->
            <div class="panel-section">
                <div class="section-title">Grower Information</div>
                <div class="form-group">
                    <label class="form-label">Select Grower</label>
                    <select class="form-select" id="growerSelect" onchange="selectGrower()">
                        <option value="">-- Select or Add New --</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn btn-outline" onclick="showAddGrower()">+ Add</button>
                    <button class="btn btn-outline" onclick="editGrower()">Edit</button>
                    <button class="btn btn-outline" onclick="deleteGrower()">Delete</button>
                </div>
            </div>
            
            <!-- Soil Data Section -->
            <div class="panel-section" id="soilSection" style="display: none;">
                <div class="section-title">🗺️ Soil Data Files</div>
                <div class="soil-list" id="soilList">
                    <div class="no-data">No soil data uploaded yet</div>
                </div>
                <div class="file-upload">
                    <input type="file" id="soilUpload" accept=".json,.geojson" onchange="handleSoilUpload(event)">
                    <label for="soilUpload" class="file-upload-label">
                        📁 Upload SSURGO Data
                    </label>
                </div>
                <div style="margin-top: 8px; padding: 8px; background: #e8f4f8; border-radius: 4px; font-size: 11px; color: #0c5460; border: 1px solid #bee5eb;">
                    <b>💡 Tip:</b> Upload all soil maps for this grower. They'll be available on all devices and auto-load with the grower.
                </div>
            </div>
            
            <!-- Field Section -->
            <div class="panel-section" id="fieldSection" style="display: none;">
                <div class="section-title">Field Management</div>
                <div class="field-list" id="fieldList">
                    <div class="no-data">No fields added yet</div>
                </div>
                <button class="btn btn-primary" onclick="showAddField()">+ Add New Field</button>
                <button class="btn btn-success" id="drawFieldBtn" onclick="drawFieldBoundary()">Draw Field Boundary</button>
            </div>
            
            <!-- Sampling Section -->
            <div class="panel-section" id="samplingSection" style="display: none;">
                <div class="section-title">Sampling</div>
                <div class="form-group">
                    <label class="form-label">Active Field: <span id="activeFieldName" style="color: #667eea; font-weight: 600;">None</span></label>
                </div>
                <button class="btn btn-warning" onclick="startSampling()">Start Sampling</button>
                <div class="form-group" style="margin-top: 10px;">
                    <label class="form-label">Sample Count: <span id="sampleCount" style="font-weight: 600;">0</span></label>
                </div>
                <div style="margin-top: 10px; padding: 8px; background: #fff9e6; border-radius: 4px; font-size: 10px; color: #856404; border: 1px solid #ffd966;">
                    <b>📱 GPS Tip:</b> Phone (cellular) GPS is more accurate than WiFi-only iPad. Use phone for field sampling, iPad for data review.
                </div>
            </div>
            
            <!-- Export Section -->
            <div class="panel-section" id="exportSection" style="display: none;">
                <div class="section-title">Data Export</div>
                <button class="btn btn-success" onclick="exportCSV()">Export Samples CSV</button>
                <button class="btn btn-outline" onclick="forceSync()" style="margin-top: 8px;">🔄 Force Sync</button>
            </div>
        </div>
    </div>
    
    <!-- Layer Controls -->
    <div class="layer-controls" id="layerControls">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <h4 style="margin: 0; font-size: 14px;">Map Layers</h4>
            <button onclick="toggleLayerPanel()" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #667eea; padding: 0;" id="layerToggleBtn">−</button>
        </div>
        <div id="layerContent">
            <div id="soilLayerToggles"></div>
            <div class="layer-toggle">
                <input type="checkbox" id="boundaryToggle" checked onchange="toggleBoundaries()">
                <label for="boundaryToggle">Field Boundaries</label>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="sampleToggle" checked onchange="toggleSamples()">
                <label for="sampleToggle">Sample Points</label>
            </div>
            <div class="layer-toggle">
                <input type="checkbox" id="satelliteToggle" checked onchange="toggleMapType()">
                <label for="satelliteToggle">Satellite View</label>
            </div>
        </div>
    </div>
    
    <!-- Status Bar -->
    <div class="status-bar">
        <span class="status-item">
            <span class="status-label">GPS:</span>
            <span class="status-value" id="gpsStatus">Waiting...</span>
        </span>
        <span class="status-item">
            <span class="status-label">Grower:</span>
            <span class="status-value" id="currentGrower">None</span>
        </span>
        <span class="status-item">
            <span class="status-label">Field:</span>
            <span class="status-value" id="currentField">None</span>
        </span>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <button class="tool-btn" onclick="toggleAllPanels()" title="Toggle Panels" style="background: #667eea; color: white;">☰</button>
        <button class="tool-btn" onclick="centerOnGPS()" title="Center on GPS">📍</button>
        <button class="tool-btn" id="dropPinBtn" onclick="dropPin()" title="Drop Sample Pin">🎯</button>
        <button class="tool-btn" onclick="zoomIn()" title="Zoom In">➕</button>
        <button class="tool-btn" onclick="zoomOut()" title="Zoom Out">➖</button>
        <button class="tool-btn" onclick="zoomToField()" title="Zoom to Field">🔍</button>
    </div>
    
    <!-- Leaflet & Supabase -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <script>
        // Supabase Config
        const SUPABASE_URL = 'https://btsqmaguhwksppibatna.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJ0c3FtYWd1aHdrc3BwaWJhdG5hIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwODcwOTksImV4cCI6MjA3NjY2MzA5OX0.JIn3WRHg3PvK2OqZBCM6CVfvsGDdHRHke9cUlAbacNA';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Global State
        let map;
        let currentLocation = null;
        let locationMarker = null;
        let drawControl = null;
        let isDrawing = false;
        let isSampling = false;
        let isOnline = navigator.onLine;
        
        let growers = {};
        let currentGrowerId = null;
        let currentFieldId = null;
        let fieldBoundaries = {};
        let sampleMarkers = [];
        let soilLayers = {}; // { fileId: L.geoJSON }
        
        // ===== SUPABASE FUNCTIONS =====
        
        async function loadAllGrowers() {
            try {
                updateSyncStatus('syncing', 'Loading growers...');
                
                const { data: growersData, error: growersError } = await supabase
                    .from('growers')
                    .select('*')
                    .order('created_at', { ascending: false });
                
                if (growersError) throw growersError;
                
                growers = {};
                for (const grower of growersData) {
                    growers[grower.id] = {
                        id: grower.id,
                        name: grower.name,
                        created: grower.created_at,
                        soilFiles: {},
                        fields: {}
                    };
                    
                    // Load soil files
                    const { data: soilData, error: soilError } = await supabase
                        .from('soil_files')
                        .select('*')
                        .eq('grower_id', grower.id);
                    
                    if (soilError) throw soilError;
                    
                    for (const soil of soilData) {
                        growers[grower.id].soilFiles[soil.id] = {
                            id: soil.id,
                            filename: soil.filename,
                            geojsonData: soil.geojson_data,
                            uploaded: soil.uploaded_at,
                            visible: false
                        };
                    }
                    
                    // Load fields
                    const { data: fieldsData, error: fieldsError } = await supabase
                        .from('fields')
                        .select('*')
                        .eq('grower_id', grower.id);
                    
                    if (fieldsError) throw fieldsError;
                    
                    for (const field of fieldsData) {
                        growers[grower.id].fields[field.id] = {
                            id: field.id,
                            name: field.name,
                            acres: field.acres,
                            boundary: field.boundary,
                            created: field.created_at,
                            samples: []
                        };
                        
                        // Load samples
                        const { data: samplesData, error: samplesError } = await supabase
                            .from('samples')
                            .select('*')
                            .eq('field_id', field.id)
                            .order('sample_number', { ascending: true });
                        
                        if (samplesError) throw samplesError;
                        
                        growers[grower.id].fields[field.id].samples = samplesData.map(s => ({
                            id: s.id,
                            number: s.sample_number,
                            lat: parseFloat(s.latitude),
                            lng: parseFloat(s.longitude),
                            soilType: s.soil_type,
                            soilInfo: s.soil_info,
                            timestamp: s.timestamp,
                            isManual: s.is_manual
                        }));
                    }
                }
                
                updateSyncStatus('synced', 'Synced ✓');
                saveToLocalStorage();
                return true;
            } catch (error) {
                console.error('Error loading growers:', error);
                updateSyncStatus('offline', 'Offline - Using local data');
                loadFromLocalStorage();
                return false;
            }
        }
        
        async function saveGrower(grower) {
            try {
                const { data, error } = await supabase
                    .from('growers')
                    .upsert({
                        id: grower.id,
                        name: grower.name,
                        created_at: grower.created
                    })
                    .select();
                
                if (error) throw error;
                saveToLocalStorage();
                return data[0];
            } catch (error) {
                console.error('Error saving grower:', error);
                saveToLocalStorage();
                throw error;
            }
        }
        
        async function deleteGrowerFromDB(growerId) {
            try {
                const { error } = await supabase
                    .from('growers')
                    .delete()
                    .eq('id', growerId);
                
                if (error) throw error;
                saveToLocalStorage();
                return true;
            } catch (error) {
                console.error('Error deleting grower:', error);
                throw error;
            }
        }
        
        async function saveField(growerId, field) {
            try {
                const { data, error } = await supabase
                    .from('fields')
                    .upsert({
                        id: field.id,
                        grower_id: growerId,
                        name: field.name,
                        acres: field.acres,
                        boundary: field.boundary,
                        created_at: field.created
                    })
                    .select();
                
                if (error) throw error;
                saveToLocalStorage();
                return data[0];
            } catch (error) {
                console.error('Error saving field:', error);
                saveToLocalStorage();
                throw error;
            }
        }
        
        async function saveSample(fieldId, sample) {
            try {
                const { data, error } = await supabase
                    .from('samples')
                    .insert({
                        field_id: fieldId,
                        sample_number: sample.number,
                        latitude: sample.lat,
                        longitude: sample.lng,
                        soil_type: sample.soilType || null,
                        soil_info: sample.soilInfo || null,
                        timestamp: sample.timestamp,
                        is_manual: sample.isManual
                    })
                    .select();
                
                if (error) throw error;
                saveToLocalStorage();
                return data[0];
            } catch (error) {
                console.error('Error saving sample:', error);
                saveToLocalStorage();
                throw error;
            }
        }
        
        async function saveSoilFile(growerId, filename, geoData) {
            try {
                const { data, error } = await supabase
                    .from('soil_files')
                    .insert({
                        grower_id: growerId,
                        filename: filename,
                        geojson_data: geoData
                    })
                    .select();
                
                if (error) throw error;
                saveToLocalStorage();
                return data[0];
            } catch (error) {
                console.error('Error saving soil file:', error);
                throw error;
            }
        }
        
        async function deleteSoilFile(fileId) {
            try {
                const { error } = await supabase
                    .from('soil_files')
                    .delete()
                    .eq('id', fileId);
                
                if (error) throw error;
                saveToLocalStorage();
                return true;
            } catch (error) {
                console.error('Error deleting soil file:', error);
                throw error;
            }
        }
        
        // LocalStorage fallback
        function saveToLocalStorage() {
            try {
                localStorage.setItem('kasFieldData', JSON.stringify({
                    growers: growers,
                    currentGrowerId: currentGrowerId,
                    currentFieldId: currentFieldId,
                    lastSaved: new Date().toISOString()
                }));
            } catch (error) {
                console.error('Error saving to localStorage:', error);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('kasFieldData');
                if (saved) {
                    const data = JSON.parse(saved);
                    growers = data.growers || {};
                    currentGrowerId = data.currentGrowerId;
                    currentFieldId = data.currentFieldId;
                    return true;
                }
            } catch (error) {
                console.error('Error loading from localStorage:', error);
            }
            return false;
        }
        
        // Sync status
        function updateSyncStatus(status, text) {
            const statusEl = document.getElementById('syncStatus');
            const textEl = document.getElementById('syncStatusText');
            
            statusEl.className = 'sync-status ' + status;
            textEl.textContent = text;
            
            if (status === 'synced') {
                setTimeout(() => {
                    statusEl.style.opacity = '0';
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 300);
                }, 2000);
            } else {
                statusEl.style.display = 'flex';
                statusEl.style.opacity = '1';
            }
        }
        
        window.addEventListener('online', async () => {
            isOnline = true;
            updateSyncStatus('syncing', 'Reconnected, syncing...');
            await loadAllGrowers();
            showToast('Back online - data synced!');
        });
        
        window.addEventListener('offline', () => {
            isOnline = false;
            updateSyncStatus('offline', 'Offline mode');
            showToast('Working offline');
        });
        
        async function forceSync() {
            updateSyncStatus('syncing', 'Syncing...');
            const success = await loadAllGrowers();
            if (success) {
                updateGrowerSelect();
                if (currentGrowerId) {
                    await selectGrower();
                }
                showToast('Data synced!');
            } else {
                showToast('Sync failed - check connection');
            }
        }
        
        // ===== MAP INITIALIZATION =====
        
        async function initMap() {
            map = L.map('map').setView([38.5, -90.5], 10);
            
            const satellite = L.tileLayer('https://mt1.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                maxZoom: 22,
                attribution: '© Google'
            }).addTo(map);
            
            const streets = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 20,
                attribution: '© OpenStreetMap'
            });
            
            window.mapLayers = { satellite, streets };
            
            // GPS
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(updateGPS, handleGPSError, {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                });
            }
            
            // Load data
            const loaded = await loadAllGrowers();
            if (loaded) {
                updateGrowerSelect();
                restoreMapElements();
            }
        }
        
        function restoreMapElements() {
            // Restore boundaries
            for (let growerId in growers) {
                const grower = growers[growerId];
                for (let fieldId in grower.fields) {
                    const field = grower.fields[fieldId];
                    if (field.boundary) {
                        const coords = field.boundary.map(c => [c.lat, c.lng]);
                        const polygon = L.polygon(coords, {
                            color: '#667eea',
                            weight: 4,
                            fillOpacity: 0.15,
                            dashArray: '10, 5'
                        });
                        fieldBoundaries[fieldId] = polygon;
                    }
                    
                    // Restore samples
                    if (field.samples) {
                        field.samples.forEach(sample => {
                            const marker = L.marker([sample.lat, sample.lng], {
                                icon: L.divIcon({
                                    html: `<div style="background: #ed8936; color: white; width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${sample.number}</div>`,
                                    iconSize: [26, 26],
                                    iconAnchor: [13, 13]
                                })
                            });
                            
                            let popup = `<div style="min-width: 180px;">`;
                            popup += `<h4 style="margin: 0 0 5px 0; color: #ed8936;">Sample #${sample.number}</h4>`;
                            popup += `<b>GPS:</b> ${sample.lat.toFixed(6)}, ${sample.lng.toFixed(6)}<br>`;
                            if (sample.soilType) popup += `<b>Soil:</b> ${sample.soilType}<br>`;
                            popup += `<b>Time:</b> ${new Date(sample.timestamp).toLocaleString()}<br>`;
                            popup += `</div>`;
                            
                            marker.bindPopup(popup);
                            sampleMarkers.push({ marker, fieldId, sample });
                        });
                    }
                }
            }
            
            // Restore selection
            if (currentGrowerId && growers[currentGrowerId]) {
                document.getElementById('growerSelect').value = currentGrowerId;
                selectGrower();
                
                if (currentFieldId && growers[currentGrowerId].fields[currentFieldId]) {
                    selectField(currentFieldId);
                }
            }
        }
        
        // GPS
        function updateGPS(position) {
            currentLocation = {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy
            };
            
            let accuracyColor = '#28a745';
            let accuracyText = 'Good';
            if (currentLocation.accuracy > 10) {
                accuracyColor = '#ffc107';
                accuracyText = 'Fair';
            }
            if (currentLocation.accuracy > 30) {
                accuracyColor = '#dc3545';
                accuracyText = 'Poor';
            }
            
            document.getElementById('gpsStatus').innerHTML = 
                `<span style="color: ${accuracyColor};">${currentLocation.lat.toFixed(5)}, ${currentLocation.lng.toFixed(5)} (±${Math.round(currentLocation.accuracy)}m - ${accuracyText})</span>`;
            
            if (locationMarker) {
                locationMarker.setLatLng([currentLocation.lat, currentLocation.lng]);
            } else {
                locationMarker = L.circleMarker([currentLocation.lat, currentLocation.lng], {
                    radius: 8,
                    fillColor: '#007AFF',
                    color: 'white',
                    weight: 3,
                    fillOpacity: 1,
                    zIndexOffset: 1000
                }).addTo(map);
                
                window.accuracyCircle = L.circle([currentLocation.lat, currentLocation.lng], {
                    radius: currentLocation.accuracy,
                    color: accuracyColor,
                    fillColor: accuracyColor,
                    fillOpacity: 0.1,
                    weight: 1
                }).addTo(map);
            }
            
            if (window.accuracyCircle) {
                window.accuracyCircle.setLatLng([currentLocation.lat, currentLocation.lng]);
                window.accuracyCircle.setRadius(currentLocation.accuracy);
                window.accuracyCircle.setStyle({ color: accuracyColor, fillColor: accuracyColor });
            }
        }
        
        function handleGPSError(error) {
            let errorMsg = 'GPS unavailable';
            if (error.code === 1) errorMsg = 'GPS permission denied';
            else if (error.code === 2) errorMsg = 'GPS signal lost';
            else if (error.code === 3) errorMsg = 'GPS timeout';
            
            document.getElementById('gpsStatus').innerHTML = `<span style="color: #dc3545;">${errorMsg}</span>`;
        }
        
        // ===== GROWER MANAGEMENT =====
        
        async function selectGrower() {
            const select = document.getElementById('growerSelect');
            currentGrowerId = select.value;
            
            if (currentGrowerId) {
                const grower = growers[currentGrowerId];
                document.getElementById('currentGrower').textContent = grower.name;
                document.getElementById('soilSection').style.display = 'block';
                document.getElementById('fieldSection').style.display = 'block';
                document.getElementById('samplingSection').style.display = 'block';
                document.getElementById('exportSection').style.display = 'block';
                
                updateSoilList();
                updateFieldList();
                loadSoilLayersForGrower();
            } else {
                document.getElementById('currentGrower').textContent = 'None';
                document.getElementById('soilSection').style.display = 'none';
                document.getElementById('fieldSection').style.display = 'none';
                document.getElementById('samplingSection').style.display = 'none';
                document.getElementById('exportSection').style.display = 'none';
                currentFieldId = null;
                clearAllSoilLayers();
            }
        }
        
        async function showAddGrower() {
            const name = prompt('Enter grower name:');
            if (name) {
                const id = crypto.randomUUID();
                const grower = {
                    id: id,
                    name: name,
                    soilFiles: {},
                    fields: {},
                    created: new Date().toISOString()
                };
                
                growers[id] = grower;
                
                try {
                    await saveGrower(grower);
                    showToast(`Grower "${name}" added and synced`);
                } catch (error) {
                    showToast(`Grower "${name}" added (will sync when online)`);
                }
                
                updateGrowerSelect();
                document.getElementById('growerSelect').value = id;
                await selectGrower();
            }
        }
        
        async function editGrower() {
            if (!currentGrowerId) {
                alert('Please select a grower first');
                return;
            }
            const newName = prompt('Edit grower name:', growers[currentGrowerId].name);
            if (newName) {
                growers[currentGrowerId].name = newName;
                try {
                    await saveGrower(growers[currentGrowerId]);
                    showToast('Grower updated');
                } catch (error) {
                    showToast('Grower updated (will sync when online)');
                }
                updateGrowerSelect();
                selectGrower();
            }
        }
        
        async function deleteGrower() {
            if (!currentGrowerId) {
                alert('Please select a grower first');
                return;
            }
            if (confirm(`Delete grower "${growers[currentGrowerId].name}" and all data?`)) {
                const fields = growers[currentGrowerId].fields;
                for (let fieldId in fields) {
                    if (fieldBoundaries[fieldId]) {
                        map.removeLayer(fieldBoundaries[fieldId]);
                        delete fieldBoundaries[fieldId];
                    }
                }
                
                clearAllSoilLayers();
                
                try {
                    await deleteGrowerFromDB(currentGrowerId);
                } catch (error) {
                    console.error('Delete from cloud failed');
                }
                
                delete growers[currentGrowerId];
                currentGrowerId = null;
                currentFieldId = null;
                updateGrowerSelect();
                selectGrower();
                showToast('Grower deleted');
            }
        }
        
        function updateGrowerSelect() {
            const select = document.getElementById('growerSelect');
            select.innerHTML = '<option value="">-- Select or Add New --</option>';
            
            for (let id in growers) {
                const option = document.createElement('option');
                option.value = id;
                option.textContent = growers[id].name;
                select.appendChild(option);
            }
        }
        
        // ===== SOIL DATA MANAGEMENT =====
        
        async function handleSoilUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!currentGrowerId) {
                alert('Please select a grower first');
                e.target.value = '';
                return;
            }
            
            const filename = prompt('Name this soil data file:', file.name.replace(/\.(geo)?json$/i, ''));
            if (!filename) {
                e.target.value = '';
                return;
            }
            
            updateSyncStatus('syncing', 'Uploading soil data...');
            
            const reader = new FileReader();
            reader.onload = async function(event) {
                try {
                    const geoData = JSON.parse(event.target.result);
                    
                    const result = await saveSoilFile(currentGrowerId, filename, geoData);
                    
                    const fileId = result.id;
                    growers[currentGrowerId].soilFiles[fileId] = {
                        id: fileId,
                        filename: filename,
                        geojsonData: geoData,
                        uploaded: result.uploaded_at,
                        visible: true
                    };
                    
                    updateSoilList();
                    createSoilLayer(fileId, filename, geoData);
                    
                    updateSyncStatus('synced', 'Soil data uploaded ✓');
                    showToast(`"${filename}" uploaded and synced`);
                } catch (error) {
                    console.error('Error uploading soil data:', error);
                    updateSyncStatus('offline', 'Upload failed');
                    showToast('Error uploading soil data');
                }
                
                e.target.value = '';
            };
            reader.readAsText(file);
        }
        
        function updateSoilList() {
            const container = document.getElementById('soilList');
            const soilFiles = growers[currentGrowerId]?.soilFiles || {};
            const fileIds = Object.keys(soilFiles);
            
            if (fileIds.length === 0) {
                container.innerHTML = '<div class="no-data">No soil data uploaded yet</div>';
                return;
            }
            
            container.innerHTML = fileIds.map(id => {
                const file = soilFiles[id];
                const featureCount = file.geojsonData?.features?.length || 0;
                return `
                    <div class="soil-item ${file.visible ? 'active' : ''}" onclick="toggleSoilFileVisibility('${id}')">
                        <div style="flex: 1;">
                            <div class="soil-name">${file.filename}</div>
                            <div class="soil-details">${featureCount} polygons • ${file.visible ? 'Visible' : 'Hidden'}</div>
                        </div>
                        <div class="item-actions">
                            <button class="icon-btn" onclick="event.stopPropagation(); deleteSoilFilePrompt('${id}')" title="Delete">🗑️</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function loadSoilLayersForGrower() {
            if (!currentGrowerId) return;
            
            clearAllSoilLayers();
            
            const soilFiles = growers[currentGrowerId].soilFiles;
            for (let fileId in soilFiles) {
                const file = soilFiles[fileId];
                createSoilLayer(fileId, file.filename, file.geojsonData);
                if (file.visible) {
                    soilLayers[fileId].addTo(map);
                }
            }
            
            updateLayerToggles();
        }
        
        function createSoilLayer(fileId, filename, geoData) {
            if (soilLayers[fileId]) {
                map.removeLayer(soilLayers[fileId]);
            }
            
            const colorMap = {};
            const baseColors = ['#8B4513', '#CD853F', '#DEB887', '#F4A460', '#D2691E', '#BC8F8F', '#DAA520', '#B8860B'];
            let colorIndex = 0;
            
            geoData.features.forEach(feature => {
                const musym = feature.properties.MUSYM;
                if (musym && !colorMap[musym]) {
                    colorMap[musym] = baseColors[colorIndex % baseColors.length];
                    colorIndex++;
                }
            });
            
            const layer = L.geoJSON(geoData, {
                style: function(feature) {
                    const musym = feature.properties.MUSYM || '';
                    return {
                        fillColor: colorMap[musym] || '#BC8F8F',
                        weight: 3,
                        opacity: 1,
                        color: '#000',
                        fillOpacity: 0.4
                    };
                },
                onEachFeature: function(feature, layer) {
                    layer.soilData = feature.properties;
                    
                    let popup = '<div style="min-width: 220px; font-size: 13px;">';
                    popup += '<h4 style="margin: 0 0 8px 0; color: #333; border-bottom: 2px solid #667eea; padding-bottom: 4px;">Soil Information</h4>';
                    
                    if (feature.properties.MUSYM) {
                        popup += `<b>Map Unit Symbol:</b> ${feature.properties.MUSYM}<br>`;
                    }
                    if (feature.properties.MUKEY) {
                        popup += `<b>MUKEY:</b> ${feature.properties.MUKEY}<br>`;
                    }
                    if (feature.properties.AREASYMBOL) {
                        popup += `<b>Survey Area:</b> ${feature.properties.AREASYMBOL}<br>`;
                    }
                    
                    const info = getSoilInfo(feature.properties.MUSYM);
                    if (info) {
                        popup += `<hr style="margin: 8px 0;">`;
                        if (info.series && !info.series.includes('Map Unit')) {
                            popup += `<b>Soil Series:</b> ${info.series}<br>`;
                            popup += `<b>Texture:</b> ${info.texture}<br>`;
                            popup += `<b>Drainage:</b> ${info.drainage}<br>`;
                            popup += `<b>Slope:</b> ${info.slope}<br>`;
                            if (info.ph) popup += `<b>pH Range:</b> ${info.ph}<br>`;
                            if (info.notes) popup += `<b>Notes:</b> <i style="font-size: 11px;">${info.notes}</i><br>`;
                        } else {
                            popup += `<i>Soil series not identified for ${feature.properties.MUSYM}</i><br>`;
                            popup += `<small>Check Web Soil Survey for interpretation</small><br>`;
                        }
                    }
                    
                    popup += `<hr style="margin: 8px 0;">`;
                    popup += `<small><a href="https://websoilsurvey.nrcs.usda.gov/" target="_blank">Web Soil Survey →</a></small>`;
                    popup += '</div>';
                    
                    layer.bindPopup(popup);
                }
            });
            
            soilLayers[fileId] = layer;
        }
        
        function toggleSoilFileVisibility(fileId) {
            if (!currentGrowerId) return;
            
            const file = growers[currentGrowerId].soilFiles[fileId];
            file.visible = !file.visible;
            
            if (file.visible && soilLayers[fileId]) {
                soilLayers[fileId].addTo(map);
                
                // Zoom to bounds if first time showing
                const bounds = soilLayers[fileId].getBounds();
                if (bounds.isValid()) {
                    map.fitBounds(bounds, { padding: [50, 50] });
                }
            } else if (soilLayers[fileId]) {
                map.removeLayer(soilLayers[fileId]);
            }
            
            updateSoilList();
            updateLayerToggles();
        }
        
        async function deleteSoilFilePrompt(fileId) {
            if (!currentGrowerId) return;
            
            const file = growers[currentGrowerId].soilFiles[fileId];
            if (confirm(`Delete soil data file "${file.filename}"?`)) {
                try {
                    await deleteSoilFile(fileId);
                } catch (error) {
                    console.error('Delete from cloud failed');
                }
                
                if (soilLayers[fileId]) {
                    map.removeLayer(soilLayers[fileId]);
                    delete soilLayers[fileId];
                }
                
                delete growers[currentGrowerId].soilFiles[fileId];
                updateSoilList();
                updateLayerToggles();
                showToast('Soil data file deleted');
            }
        }
        
        function clearAllSoilLayers() {
            for (let fileId in soilLayers) {
                if (soilLayers[fileId]) {
                    map.removeLayer(soilLayers[fileId]);
                }
            }
            soilLayers = {};
            updateLayerToggles();
        }
        
        function updateLayerToggles() {
            const container = document.getElementById('soilLayerToggles');
            
            if (!currentGrowerId) {
                container.innerHTML = '';
                return;
            }
            
            const soilFiles = growers[currentGrowerId].soilFiles;
            const fileIds = Object.keys(soilFiles);
            
            if (fileIds.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            container.innerHTML = fileIds.map(fileId => {
                const file = soilFiles[fileId];
                return `
                    <div class="layer-toggle">
                        <input type="checkbox" id="soil_${fileId}" ${file.visible ? 'checked' : ''} onchange="toggleSoilFileVisibility('${fileId}')">
                        <label for="soil_${fileId}">${file.filename}</label>
                    </div>
                `;
            }).join('');
            
            if (fileIds.length > 0) {
                container.innerHTML += '<hr style="margin: 10px 0;">';
            }
        }
        
        function getSoilInfo(musym) {
            const soilData = {
                '79B': { 
                    series: 'Menfro silt loam', 
                    texture: 'Silt loam', 
                    drainage: 'Well drained', 
                    slope: '0-2% slopes',
                    ph: '5.5-7.3',
                    notes: 'Deep, well-drained loess soils'
                },
                '79C2': { 
                    series: 'Menfro silt loam', 
                    texture: 'Silt loam', 
                    drainage: 'Well drained', 
                    slope: '2-5% slopes, eroded',
                    ph: '5.5-7.3',
                    notes: 'Good for vineyards with proper erosion control'
                },
                '79D2': { 
                    series: 'Menfro silt loam', 
                    texture: 'Silt loam', 
                    drainage: 'Well drained', 
                    slope: '5-10% slopes, eroded',
                    ph: '5.5-7.3',
                    notes: 'Steeper slopes, manage erosion'
                },
                '79D3': { 
                    series: 'Menfro silt loam', 
                    texture: 'Silt loam', 
                    drainage: 'Well drained', 
                    slope: '5-10% slopes, severely eroded',
                    ph: '5.5-7.3',
                    notes: 'Severely eroded, may need restoration'
                },
                '79E2': { 
                    series: 'Menfro silt loam', 
                    texture: 'Silt loam', 
                    drainage: 'Well drained', 
                    slope: '10-15% slopes, eroded',
                    ph: '5.5-7.3',
                    notes: 'Steep slopes, erosion concern'
                },
                '90601': {
                    series: 'Memphis silt loam',
                    texture: 'Silt loam',
                    drainage: 'Well drained',
                    slope: '0-2% slopes',
                    ph: '5.1-6.5',
                    notes: 'Deep, well-drained loess soils, excellent for vineyards'
                },
                '90021': {
                    series: 'Memphis silt loam',
                    texture: 'Silt loam',
                    drainage: 'Well drained',
                    slope: '2-5% slopes',
                    ph: '5.1-6.5',
                    notes: 'Good agricultural soil, moderate slope'
                },
                '90017': {
                    series: 'Memphis silt loam',
                    texture: 'Silt loam',
                    drainage: 'Well drained',
                    slope: '0-2% slopes',
                    ph: '5.1-6.5',
                    notes: 'Prime farmland when not flooded'
                }
            };
            
            if (soilData[musym]) {
                return soilData[musym];
            } else {
                return {
                    series: `Map Unit ${musym}`,
                    texture: 'See Web Soil Survey',
                    drainage: 'See Web Soil Survey',
                    slope: 'Varies',
                    notes: 'Check SSURGO data tables or Web Soil Survey for detailed interpretation'
                };
            }
        }
        
        // ===== FIELD MANAGEMENT =====
        
        async function showAddField() {
            if (!currentGrowerId) {
                alert('Please select a grower first');
                return;
            }
            
            const name = prompt('Enter field name (e.g., North Block, Vineyard A):');
            if (name) {
                const acres = prompt('Enter approximate acres (optional):');
                const id = crypto.randomUUID();
                
                const field = {
                    id: id,
                    name: name,
                    acres: acres || '',
                    boundary: null,
                    samples: [],
                    created: new Date().toISOString()
                };
                
                growers[currentGrowerId].fields[id] = field;
                
                try {
                    await saveField(currentGrowerId, field);
                    showToast(`Field "${name}" added and synced`);
                } catch (error) {
                    showToast(`Field "${name}" added (will sync when online)`);
                }
                
                updateFieldList();
                selectField(id);
            }
        }
        
        function updateFieldList() {
            const container = document.getElementById('fieldList');
            const fields = growers[currentGrowerId]?.fields || {};
            const fieldIds = Object.keys(fields);
            
            if (fieldIds.length === 0) {
                container.innerHTML = '<div class="no-data">No fields added yet</div>';
                return;
            }
            
            container.innerHTML = fieldIds.map(id => {
                const field = fields[id];
                const isActive = currentFieldId === id;
                return `
                    <div class="field-item ${isActive ? 'active' : ''}" onclick="selectField('${id}')">
                        <div class="field-name">${field.name}</div>
                        <div class="field-details">
                            ${field.acres ? field.acres + ' acres' : 'No acreage set'}
                            ${field.boundary ? ' • Boundary set' : ''}
                            ${field.samples?.length > 0 ? ' • ' + field.samples.length + ' samples' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function selectField(fieldId) {
            currentFieldId = fieldId;
            const field = growers[currentGrowerId].fields[fieldId];
            
            document.getElementById('currentField').textContent = field.name;
            document.getElementById('activeFieldName').textContent = field.name;
            document.getElementById('sampleCount').textContent = field.samples?.length || 0;
            
            updateFieldList();
            
            // Show only this field's boundary
            for (let id in fieldBoundaries) {
                if (fieldBoundaries[id]) {
                    if (id === fieldId) {
                        fieldBoundaries[id].addTo(map);
                    } else {
                        map.removeLayer(fieldBoundaries[id]);
                    }
                }
            }
            
            // Show only this field's samples
            sampleMarkers.forEach(item => {
                if (item.fieldId === fieldId && document.getElementById('sampleToggle').checked) {
                    item.marker.addTo(map);
                } else {
                    map.removeLayer(item.marker);
                }
            });
            
            if (fieldBoundaries[fieldId]) {
                map.fitBounds(fieldBoundaries[fieldId].getBounds(), { padding: [50, 50] });
            }
        }
        
        async function drawFieldBoundary() {
            if (!currentFieldId) {
                alert('Please select a field first');
                return;
            }
            
            if (isDrawing) {
                if (drawControl) drawControl.disable();
                isDrawing = false;
                document.getElementById('drawFieldBtn').textContent = 'Draw Field Boundary';
                document.getElementById('drawFieldBtn').classList.remove('btn-danger');
                document.getElementById('drawFieldBtn').classList.add('btn-success');
                return;
            }
            
            isDrawing = true;
            document.getElementById('drawFieldBtn').textContent = 'Cancel Drawing';
            document.getElementById('drawFieldBtn').classList.remove('btn-success');
            document.getElementById('drawFieldBtn').classList.add('btn-danger');
            
            drawControl = new L.Draw.Polygon(map, {
                shapeOptions: {
                    color: '#667eea',
                    weight: 4,
                    fillOpacity: 0.15,
                    dashArray: '10, 5'
                }
            });
            
            drawControl.enable();
            
            map.once('draw:created', async function(e) {
                const layer = e.layer;
                
                if (fieldBoundaries[currentFieldId]) {
                    map.removeLayer(fieldBoundaries[currentFieldId]);
                }
                
                fieldBoundaries[currentFieldId] = layer;
                layer.addTo(map);
                
                const coords = layer.getLatLngs()[0].map(ll => ({
                    lat: ll.lat,
                    lng: ll.lng
                }));
                growers[currentGrowerId].fields[currentFieldId].boundary = coords;
                
                isDrawing = false;
                document.getElementById('drawFieldBtn').textContent = 'Draw Field Boundary';
                document.getElementById('drawFieldBtn').classList.remove('btn-danger');
                document.getElementById('drawFieldBtn').classList.add('btn-success');
                
                try {
                    await saveField(currentGrowerId, growers[currentGrowerId].fields[currentFieldId]);
                    showToast('Field boundary saved and synced');
                } catch (error) {
                    showToast('Field boundary saved (will sync when online)');
                }
                
                updateFieldList();
            });
        }
        
        function zoomToField() {
            if (currentFieldId && fieldBoundaries[currentFieldId]) {
                map.fitBounds(fieldBoundaries[currentFieldId].getBounds(), { padding: [50, 50] });
            } else {
                showToast('No field boundary to zoom to');
            }
        }
        
        // ===== SAMPLING =====
        
        function startSampling() {
            if (!currentFieldId) {
                alert('Please select a field first');
                return;
            }
            
            isSampling = !isSampling;
            const btn = document.querySelector('.btn-warning');
            
            if (isSampling) {
                btn.textContent = 'Stop Sampling';
                btn.classList.add('btn-danger');
                btn.classList.remove('btn-warning');
                document.getElementById('dropPinBtn').classList.add('active');
                showToast('Sampling mode active - Click 🎯 to drop pins');
            } else {
                btn.textContent = 'Start Sampling';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-warning');
                document.getElementById('dropPinBtn').classList.remove('active');
                showToast('Sampling mode stopped');
            }
        }
        
        function dropPin() {
            if (!isSampling) {
                showToast('Start sampling mode first');
                return;
            }
            
            if (!currentFieldId) {
                showToast('Select a field first');
                return;
            }
            
            if (!currentLocation) {
                showToast('Click on map to place pin');
                map.once('click', function(e) {
                    placeSamplePin(e.latlng.lat, e.latlng.lng, true);
                });
                return;
            }
            
            placeSamplePin(currentLocation.lat, currentLocation.lng, false);
        }
        
        async function placeSamplePin(lat, lng, isManual) {
            let soilType = '';
            let soilInfo = null;
            
            // Check all active soil layers
            const point = L.latLng(lat, lng);
            for (let fileId in soilLayers) {
                if (growers[currentGrowerId].soilFiles[fileId].visible) {
                    soilLayers[fileId].eachLayer(function(layer) {
                        if (layer.getBounds && layer.getBounds().contains(point) && layer.soilData) {
                            soilType = layer.soilData.MUSYM || '';
                            soilInfo = getSoilInfo(soilType);
                        }
                    });
                }
            }
            
            const field = growers[currentGrowerId].fields[currentFieldId];
            const sampleNum = (field.samples?.length || 0) + 1;
            
            const marker = L.marker([lat, lng], {
                icon: L.divIcon({
                    html: `<div style="background: #ed8936; color: white; width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${sampleNum}</div>`,
                    iconSize: [26, 26],
                    iconAnchor: [13, 13]
                })
            }).addTo(map);
            
            let popup = '<div style="min-width: 200px;">';
            popup += `<h4 style="margin: 0 0 5px 0; color: #ed8936;">Sample #${sampleNum}</h4>`;
            popup += `<b>Field:</b> ${field.name}<br>`;
            if (soilType) {
                popup += `<b>Soil Unit:</b> ${soilType}<br>`;
                if (soilInfo && soilInfo.series && !soilInfo.series.includes('Map Unit')) {
                    popup += `<b>Series:</b> ${soilInfo.series}<br>`;
                    popup += `<b>Texture:</b> ${soilInfo.texture}<br>`;
                    popup += `<b>Drainage:</b> ${soilInfo.drainage}<br>`;
                    popup += `<b>pH:</b> ${soilInfo.ph}<br>`;
                }
            }
            popup += `<b>GPS:</b> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>`;
            popup += `<b>Time:</b> ${new Date().toLocaleString()}<br>`;
            if (isManual) popup += `<i style="color: #666;">Manual placement</i>`;
            popup += '</div>';
            
            marker.bindPopup(popup);
            
            const sample = {
                id: crypto.randomUUID(),
                number: sampleNum,
                lat: lat,
                lng: lng,
                soilType: soilType,
                soilInfo: soilInfo,
                timestamp: new Date().toISOString(),
                isManual: isManual
            };
            
            if (!field.samples) field.samples = [];
            field.samples.push(sample);
            
            sampleMarkers.push({ marker, fieldId: currentFieldId, sample });
            
            document.getElementById('sampleCount').textContent = field.samples.length;
            
            try {
                await saveSample(currentFieldId, sample);
                showToast(`Sample #${sampleNum} placed and synced${soilType ? ' - Soil: ' + soilType : ''}`);
            } catch (error) {
                showToast(`Sample #${sampleNum} placed (will sync when online)${soilType ? ' - Soil: ' + soilType : ''}`);
            }
        }
        
        // ===== UI FUNCTIONS =====
        
        function toggleAllPanels() {
            const mainContent = document.getElementById('mainPanelContent');
            const layerContent = document.getElementById('layerContent');
            
            if (mainContent.style.display !== 'none' || layerContent.style.display !== 'none') {
                mainContent.style.display = 'none';
                layerContent.style.display = 'none';
                document.getElementById('mainPanelToggleBtn').textContent = '+';
                document.getElementById('layerToggleBtn').textContent = '+';
                showToast('Panels hidden');
            } else {
                mainContent.style.display = 'block';
                layerContent.style.display = 'block';
                document.getElementById('mainPanelToggleBtn').textContent = '−';
                document.getElementById('layerToggleBtn').textContent = '−';
                showToast('Panels visible');
            }
        }
        
        function toggleMainPanel() {
            const content = document.getElementById('mainPanelContent');
            const btn = document.getElementById('mainPanelToggleBtn');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = '−';
            } else {
                content.style.display = 'none';
                btn.textContent = '+';
            }
        }
        
        function toggleLayerPanel() {
            const content = document.getElementById('layerContent');
            const btn = document.getElementById('layerToggleBtn');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                btn.textContent = '−';
            } else {
                content.style.display = 'none';
                btn.textContent = '+';
            }
        }
        
        function toggleBoundaries() {
            const show = document.getElementById('boundaryToggle').checked;
            for (let id in fieldBoundaries) {
                if (fieldBoundaries[id]) {
                    if (show && (id === currentFieldId || !currentFieldId)) {
                        fieldBoundaries[id].addTo(map);
                    } else {
                        map.removeLayer(fieldBoundaries[id]);
                    }
                }
            }
        }
        
        function toggleSamples() {
            const show = document.getElementById('sampleToggle').checked;
            sampleMarkers.forEach(item => {
                if (show && (!currentFieldId || item.fieldId === currentFieldId)) {
                    item.marker.addTo(map);
                } else {
                    map.removeLayer(item.marker);
                }
            });
        }
        
        function toggleMapType() {
            const useSatellite = document.getElementById('satelliteToggle').checked;
            if (useSatellite) {
                map.removeLayer(window.mapLayers.streets);
                map.addLayer(window.mapLayers.satellite);
            } else {
                map.removeLayer(window.mapLayers.satellite);
                map.addLayer(window.mapLayers.streets);
            }
        }
        
        function exportCSV() {
            if (!currentGrowerId) {
                alert('No grower selected');
                return;
            }
            
            let csv = 'Grower,Field,Sample_Number,Latitude,Longitude,Soil_Unit,Soil_Series,Texture,Drainage,pH,Date_Time\n';
            
            const grower = growers[currentGrowerId];
            for (let fieldId in grower.fields) {
                const field = grower.fields[fieldId];
                if (field.samples) {
                    field.samples.forEach(sample => {
                        csv += `"${grower.name}",`;
                        csv += `"${field.name}",`;
                        csv += `${sample.number},`;
                        csv += `${sample.lat.toFixed(6)},`;
                        csv += `${sample.lng.toFixed(6)},`;
                        csv += `${sample.soilType || ''},`;
                        csv += `"${sample.soilInfo?.series || ''}",`;
                        csv += `"${sample.soilInfo?.texture || ''}",`;
                        csv += `"${sample.soilInfo?.drainage || ''}",`;
                        csv += `"${sample.soilInfo?.ph || ''}",`;
                        csv += `"${new Date(sample.timestamp).toLocaleString()}"\n`;
                    });
                }
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `samples_${grower.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            window.URL.revokeObjectURL(url);
            
            showToast('CSV exported');
        }
        
        function centerOnGPS() {
            if (currentLocation) {
                map.setView([currentLocation.lat, currentLocation.lng], 18);
            } else {
                showToast('GPS not available');
            }
        }
        
        function zoomIn() {
            map.zoomIn();
        }
        
        function zoomOut() {
            map.zoomOut();
        }
        
        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // Initialize
        window.addEventListener('load', initMap);
    </script>
</body>
</html>